# 基本知识

1.	对于一个空类，如：

```
class EmptyClass{};      
```    
虽然你没有声明任何函数，但是编译器会自动为你提供上面这四个方法。

```
class CEmptyClass
{
public:
	CEmptyClass(); // 构造函数
	CEmptyClass(const CEmptyClass &rhs);// 拷贝构造函数
	~CEmptyClass(); // 析构函数 
	CEmptyClass& operator = (const CEmptyClass& rhs);// 赋值函数
};      
```

对于这四个方法的任何一个，你的类如果没有声明，那么编译器就会自动为你对应的提供一个默认的。（在《C++ primer》中，这个编译器自动提供的版本叫做“**合成的**\*\*\*”，例如合成的复制构造函数）当然如果你显式声明了，编译器就不会再提供相应的方法。

2.	合成的默认构造函数执行内容：如果有父类，就先调用父类的默认构造函数。

3.	合成的复制构造函数执行内容：使用参数中的对象，构造出一个新的对象。

4.合成的赋值操作符执行内容：使用参数中的对象，使用参数对象的非static成员依次对目标对象的成员赋值。注意：在赋值操作符执行之前，目标对象已经存在。

5.	在继承体系中，要将基类（或称为父类）的析构函数，声明为virtual方法（即虚函数）。

6.	子类中包含父类的成员。即子类有两个部分组成，父类部分和子类自己定义的部分。

7.	如果在子类中显式调用父类的构造函数，只能在构造函数的初始化列表中调用，并且只能调用其直接父类的。

8.	在多重继承时，按照基类继承列表中声明的顺序初始化父类。

9.	在虚继承中，虚基类的初始化 早于 非虚基类，并且子类来初始化虚基类（注意：虚基类不一定是子类的直接父类）。

10.	在单一的继承中，被 OverWrite 的虚函数在虚函数表中得到了更新。

11.	可以看陈皓的博客 http://blog.csdn.net/haoel/article/details/1948051