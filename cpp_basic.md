# 基本知识

1.对于一个空类，如：

```
class EmptyClass{};      
```    
虽然你没有声明任何函数，但是编译器会自动为你提供上面这四个方法。

```
class CEmptyClass
{
public:
	CEmptyClass(); // 构造函数
	CEmptyClass(const CEmptyClass &rhs);// 拷贝构造函数
	~CEmptyClass(); // 析构函数 
	CEmptyClass& operator = (const CEmptyClass& rhs);// 赋值函数
};      
```

对于这四个方法的任何一个，你的类如果没有声明，那么编译器就会自动为你对应的提供一个默认的。（在《C++ primer》中，这个编译器自动提供的版本叫做“**合成的**\*\*\*”，例如合成的复制构造函数）当然如果你显式声明了，编译器就不会再提供相应的方法。

2.合成的默认构造函数执行内容：如果有父类，就先调用父类的默认构造函数。

3.合成的复制构造函数执行内容：使用参数中的对象，构造出一个新的对象。

4.合成的赋值操作符执行内容：使用参数中的对象，使用参数对象的非static成员依次对目标对象的成员赋值。注意：在赋值操作符执行之前，目标对象已经存在。

5.在继承体系中，要将基类（或称为父类）的析构函数，声明为virtual方法（即虚函数）。

6.子类中包含父类的成员。即子类有两个部分组成，父类部分和子类自己定义的部分。

7.如果在子类中显式调用父类的构造函数，只能在构造函数的初始化列表中调用，并且只能调用其直接父类的。

8.在多重继承时，按照基类继承列表中声明的顺序初始化父类。

9.在虚继承中，虚基类的初始化 早于 非虚基类，并且子类来初始化虚基类（注意：虚基类不一定是子类的直接父类）。

10.在单一的继承中，被 OverWrite 的虚函数在虚函数表中得到了更新。

11.可以看陈皓的博客 http://blog.csdn.net/haoel/article/details/1948051


# 构造函数

1.在构造子类之前一定执行父类的、一个、构造函数。

2.构造函数的顺序:

&ensp;&ensp;①直接父类；
  
&ensp;&ensp;② 自己 ，若直接父类还有父类，那么直接父类的父类会在直接父类之前构造。
  
  可以理解为这是一个递归的过程，直到出现一个没有父类的类才停止。
  
&ensp;&ensp;2.1 如果没有**显式定义**自己的构造函数，则合成的默认构造函数会自动调用直接父类的默认构造函数，然后调用编译器为自己生成的合成默认构造函数。

&ensp;&ensp;2.2 如果**显式定义**了自己的构造函数

&ensp;&ensp;&ensp;&ensp;2.2.1 如果没有**显式调用**直接父类的任意一个构造函数，那么和合成的默认构造函数一样，会先自动调用直接父类的默认构造函数，然后调用自己的构造函数。

&ensp;&ensp;&ensp;&ensp;2.2.2 如果**显式调用**了直接父类的任意一个构造函数，那么会先调用直接父类的构造函数，然后调用自己的构造函数。

3.析构函数 与构造函数顺序相反。

```cpp
#include <stdio.h>
class Test
{
public:
	Test(int) {}
	Test(void) {}
	void fun() {}
};

int main()
{

	Test a(1);
	a.fun();

	Test b();// 这是不对的 会被识别为函数声明
	b.fun();
	return 0;
}
```
